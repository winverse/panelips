# 서버 아키텍처 가이드

이 문서는 NestJS로 구축된 Panelips 서버 애플리케이션의 아키텍처 원칙을 설명합니다. 목표는 계층형 아키텍처를 통해 관심사를 명확하게 분리하여 깔끔하고 확장 가능하며 유지보수하기 쉬운 코드베이스를 유지하는 것입니다.

## 핵심 원칙

- **엄격한 단방향 의존성 흐름**: 의존성은 반드시 `modules` -> `core` -> `common`의 한 방향으로 흘러야 합니다. 각 계층은 자신보다 하위 계층에만 의존할 수 있습니다. 이는 순환 참조를 원천적으로 방지합니다.
- **관심사의 분리 (Separation of Concerns)**: 각 계층과 모듈은 명확하고 예측 가능한 책임을 가집니다.
- **테스트 용이성**: 의존성 주입(DI)과 명확한 경계를 활용하여 단위 테스트와 통합 테스트를 쉽게 작성할 수 있도록 설계되었습니다.

---

## 아키텍처의 '의존성'에 대한 이해

이 아키텍처에서 '의존성'은 두 가지 형태로 존재하며, 둘의 차이를 이해하는 것이 중요합니다.

1.  **런타임 의존성 (Runtime Dependency via DI)**
    - **관계**: `modules` -> `core`
    - **설명**: NestJS의 DI 컨테이너가 관리하는 **객체 인스턴스**에 대한 의존성입니다. 예를 들어, `YoutubeService`는 `MongoService`의 특정 인스턴스가 필요합니다. 이는 제어의 역전(IoC) 원칙에 따라 런타임에 프레임워크가 의존성을 '주입'해주는 형태입니다.
    - **목적**: 의존성 교체(테스트 용이성), 생명주기 관리(싱글턴 등), 복잡한 초기화 처리 등을 위함입니다.

2.  **소스 코드 의존성 (Source Code Dependency via Import)**
    - **관계**: `modules` -> `common`, `core` -> `common`
    - **설명**: 특정 기능(함수, 타입, 상수 등)의 **소스 코드**에 대한 의존성입니다. 예를 들어, `core` 계층의 파일이 `common`의 `formatDate` 함수를 사용한다면, 해당 파일은 `formatDate` 함수의 코드를 `import` 해야만 컴파일(실행)될 수 있습니다.
    - **목적**: 상태가 없고, 교체가 필요 없는 순수한 유틸리티를 재사용하기 위함입니다.

**`modules -> core -> common` 규칙은 이 두 종류의 의존성을 모두 포괄하는 코드의 '방향성'에 대한 규칙입니다.** 이 방향을 엄격히 지킴으로써 코드베이스의 예측 가능성을 높이고 순환 참조를 방지합니다.

---

## 디렉토리 구조 및 계층

### 📂 `src/`

- **`main.ts`**: 애플리케이션의 진입점입니다.
- **`app.module.ts`**: 애플리케이션의 주요 구성 요소를 조립하는 최상위 루트 모듈입니다.

### 📂 `src/core/`

`core` 계층은 애플리케이션 인프라의 심장부입니다. NestJS의 DI 컨테이너가 관리하는 필수적인 전역 서비스를 제공합니다.

- **역할**: 외부 시스템(데이터베이스 등)과의 연결을 관리하고, 전역 설정을 처리하며, 로깅이나 HTTP 클라이언트와 같은 기타 기반 서비스를 제공합니다.
- **특징**:
    - `@Injectable()` 서비스들을 포함합니다.
    - `CoreModule`에서 `@Global()`로 설정되어, 다른 모듈에서 매번 `import` 하지 않아도 프로바이더를 즉시 주입받을 수 있습니다.
    - **상태를 가집니다 (Stateful)** (예: DB 커넥션 객체).
- **의존성 규칙**: **절대 `modules` 계층이나 특정 기능에 의존해서는 안 됩니다.** 기능들이 구축되는 기반 역할을 합니다.
- **예시**: `MongoService`, `ConfigService`, `LoggerService`.

### 📂 `src/common/`

`common` 계층은 재사용 가능한, 상태 없는 유틸리티의 도구 상자입니다. 애플리케이션의 비즈니스 로직이나 인프라로부터 완전히 독립적입니다.

- **역할**: 특정 도메인에 묶이지 않는 순수 함수, 타입 정의(인터페이스/enum), 커스텀 에러 정의, 상수 등을 제공합니다.
- **특징**:
    - **`@Injectable()` 서비스를 포함하지 않습니다.** NestJS의 DI 컨테이너의 존재를 알아서는 안 됩니다.
    - **상태가 없습니다 (Stateless)**.
    - 필요한 곳에서 직접 `import`하여 사용합니다.
- **의존성 규칙**: **다른 어떤 계층(`core`, `modules`)에도 의존하지 않습니다.** 코드베이스에서 가장 독립적인 부분입니다.
- **예시**: `formatDate()`, `parseISO8601Duration()`, `YOUTUBE_ERROR` 상수, `PaginationRequest` 인터페이스.

### 📂 `src/modules/`

`modules` 계층은 애플리케이션의 기능들을 도메인별로 그룹화하여 포함합니다.

- **역할**: 애플리케이션의 구체적인 비즈니스 로직을 구현합니다. 각 하위 디렉토리는 `users`, `sns`, `products`와 같이 기능적으로 독립된 도메인입니다.
- **모듈의 구조**:
    - **`*.module.ts`**: 기능을 캡슐화하는 NestJS 모듈 파일. 필요한 모듈을 가져오고 내부 컴포넌트(컨트롤러, 서비스)를 선언합니다.
    - **`*.controller.ts` / `*.router.ts`**: 외부 요청(HTTP, RPC 등)을 받고, 입력값을 검증하며, 적절한 서비스를 호출합니다. 모듈 로직의 진입점입니다.
    - **`*.service.ts`**: 핵심 비즈니스 로직을 포함합니다. 데이터 흐름을 조율하고, `core` 계층과 상호작용하며(예: DB 접근), 계산을 수행합니다.
    - **`*.repository.ts` (선택 사항)**: 데이터 접근 로직을 추상화하여, 데이터를 사용하는 서비스로부터 쿼리 방법을 분리할 때 사용합니다.
- **의존성 규칙**: `core`와 `common`에 의존할 수 있습니다. 다른 모듈에 의존할 수도 있으며, 이 경우 `*.module.ts` 파일의 `imports` 배열을 통해 명시적으로 관리해야 합니다.

---

## 의존성 흐름 예시: `YoutubeService`

1.  **`YoutubeController`**가 요청을 받습니다.
2.  컨트롤러는 **`YoutubeService`**의 메소드를 호출합니다.
3.  **`YoutubeService`**는 데이터베이스에 접근하기 위해 `this.mongoService.find(...)`를 호출합니다.
    - `MongoService`는 **`core`** 계층에서 주입받은 서비스입니다. (런타임 의존성)
4.  **`YoutubeService`**는 날짜 문자열을 파싱하기 위해 `parseISO8601Duration(...)` 함수를 호출합니다.
    - `parseISO8601Duration` 함수는 **`common`** 계층에서 직접 `import`해서 가져온 유틸리티입니다. (소스 코드 의존성)
5.  **`YoutubeService`**는 특정 에러 상황을 마주하여 `YOUTUBE_ERROR`에 정의된 메시지로 `NotFoundException`을 발생시킵니다.
    - `YOUTUBE_ERROR` 상수는 **`common`** 계층에서 직접 `import`해서 가져온 값입니다. (소스 코드 의존성)

이 흐름은 `modules`의 기능이 어떻게 `core`의 기반 서비스와 `common`의 상태 없는 도구를 활용하면서도, 명확하고 단방향의 의존성 체인을 유지하는지 보여줍니다.
