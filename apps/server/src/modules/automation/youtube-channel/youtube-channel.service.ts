import fs from 'node:fs/promises';
import path from 'node:path';
import {
  JsonPromptResult,
  ScriptPromptResult,
  YoutubeChannelScrapArgs,
} from '@modules/automation/youtube-channel/youtube-channel.interface.js';
import { YoutubeRepository } from '@modules/youtube/index.js';
import { InjectQueue } from '@nestjs/bullmq';
import { Injectable, Logger } from '@nestjs/common';
import { ONE_MINUTE_AS_S, ONE_SECOND_AS_MS } from '@src/common/constants/time.js';
import {
  createYoutubeJsonPrompt,
  createYoutubeVideoScriptPrompt,
} from '@src/common/prompts/index.js';
import { extractYouTubeVideoId } from '@src/common/utils/index.js';
import { Queue } from 'bullmq';
import { sleep } from 'bun';
import { Dictionary, PlaywrightCrawler, RequestQueue } from 'crawlee';
import { Page } from 'playwright';

@Injectable()
export class YoutubeChannelService {
  private readonly logger = new Logger(YoutubeChannelService.name);

  // --- üí° ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï Î≥ÄÏàò ---
  private readonly TIMEOUT_MINUTES = 3; // 5Î∂ÑÏúºÎ°ú ÏÑ§Ï†ï
  private readonly TIMEOUT_SECONDS = this.TIMEOUT_MINUTES * ONE_MINUTE_AS_S;
  private readonly TIMEOUT_MILLIS = this.TIMEOUT_SECONDS * ONE_SECOND_AS_MS;
  // --------------------------

  private readonly USER_DATA_DIR = path.resolve(process.cwd(), 'playwright', 'user-data');
  private readonly DEBUG_PATH = path.resolve(process.cwd(), 'playwright', 'debug');

  private readonly GEMINI_URL = 'https://gemini.google.com/app';
  private readonly NEW_CHAT_BUTTON_SELECTOR = '[data-test-id="new-chat-button"]';
  private readonly INPUT_SELECTOR =
    'div.ql-editor.textarea.new-input-ui[data-placeholder="GeminiÏóêÍ≤å Î¨ºÏñ¥Î≥¥Í∏∞"][role="textbox"][contenteditable="true"]';
  private readonly LOTTIE_ANIMATION_SELECTOR =
    'div.avatar_primary_animation.is-gpi-avatar[data-test-lottie-animation-status="completed"]';
  private readonly CHAT_HISTORY_CONTAINER_SELECTOR =
    '#chat-history infinite-scroller[data-test-id="chat-history-container"]';
  private readonly LAST_CONVERSATION_SELECTOR =
    `${this.CHAT_HISTORY_CONTAINER_SELECTOR} div.conversation-container.message-actions-hover-boundary:last-child`;
  private readonly LAST_MODEL_RESPONSE_SELECTOR =
    `${this.LAST_CONVERSATION_SELECTOR} model-response message-content.model-response-text`;
  private readonly COPY_BUTTON_SELECTOR =
    `${this.LAST_CONVERSATION_SELECTOR} button[aria-label="ÏΩîÎìú Î≥µÏÇ¨"]`;
  private readonly COMPLETION_KEYWORD = '"response": "completed"';

  constructor(
    private readonly youtubeRepository: YoutubeRepository,
    @InjectQueue('scraping-queue') private readonly scrapingQueue: Queue,
  ) {}

  public async addScrapingJob(data: YoutubeChannelScrapArgs) {
    await this.scrapingQueue.add('scrape-youtube-channel', data, {
      attempts: 3, // Ïã§Ìå® Ïãú 3Î≤à Ïû¨ÏãúÎèÑ
      backoff: {
        type: 'exponential',
        delay: 1000, // 1Ï¥à, 2Ï¥à, 4Ï¥à Í∞ÑÍ≤©ÏúºÎ°ú Ïû¨ÏãúÎèÑ
      },
    });
    this.logger.log(`Scraping job added to queue for URL: ${data.url}`);
    return { success: true, message: 'Ïä§ÌÅ¨Îû© ÏûëÏóÖÏù¥ ÌÅêÏóê Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.' };
  }

  public async youtubeChannelScrap({
    title,
    url,
    description,
    channelId,
  }: YoutubeChannelScrapArgs) {
    const videoId = extractYouTubeVideoId(url);
    if (!videoId) {
      throw new Error('Invalid YouTube video URL');
    }

    await sleep(1000);
    const jsonPrompt = createYoutubeJsonPrompt({ title, description, url, channelId, videoId });
    const scriptPrompt = createYoutubeVideoScriptPrompt({ title, description, url, videoId });

    this.logger.log('üöÄ Starting scraping process with persistent user profile...');
    this.logger.log(`üë§ Using user data directory: ${this.USER_DATA_DIR}`);
    const isJsonAnalysisComplete = await this.youtubeRepository.isJsonAnalysisComplete(url);
    const isScriptAnalysisComplete = await this.youtubeRepository.isScriptAnalysisComplete(url);

    if (isJsonAnalysisComplete && isScriptAnalysisComplete) {
      this.logger.log('already created json and script');
      return;
    }

    const video = await this.youtubeRepository.findVideoByUrl(url);
    if (!video) {
      await this.youtubeRepository.createVideo({
        title,
        url,
        videoId,
        description,
        summary: '',
        publishedAt: new Date(),
        isRelatedAsset: false,
        relatedStocks: [],
        channel: {
          connect: {
            channelId,
          },
        },
      });
    }

    const queueName = `youtube-prompts-${videoId}`;
    const oldQueue = await RequestQueue.open(queueName);
    await oldQueue.drop();
    const requestQueue = await RequestQueue.open(queueName);

    if (!isJsonAnalysisComplete) {
      await requestQueue.addRequest({
        url: this.GEMINI_URL,
        uniqueKey: `json-${url}`,
        userData: { prompt: jsonPrompt, type: 'json', videoUrl: url },
      });
    }

    if (!isScriptAnalysisComplete) {
      await requestQueue.addRequest({
        url: this.GEMINI_URL,
        uniqueKey: `script-${url}`,
        userData: { prompt: scriptPrompt, type: 'script', videoUrl: url },
      });
    }

    const crawler = new PlaywrightCrawler({
      requestQueue,
      maxRequestRetries: 2,
      useSessionPool: false,
      maxConcurrency: 1,
      navigationTimeoutSecs: this.TIMEOUT_SECONDS,
      requestHandlerTimeoutSecs: this.TIMEOUT_SECONDS,
      browserPoolOptions: {
        useFingerprints: true,
        fingerprintOptions: {
          fingerprintGeneratorOptions: {
            locales: ['ko-KR', 'ko'],
            devices: ['desktop'],
          },
        },
      },
      launchContext: {
        userDataDir: this.USER_DATA_DIR,
        // useChrome: true,
        launchOptions: {
          headless: false,
          args: [
            '--proxy-server=direct://',
            '--proxy-bypass-list=*',
            '--disable-blink-features=AutomationControlled',
            '--disable-web-security', // Ï∂îÍ∞Ä Í∂åÏû•
            '--disable-features=VizDisplayCompositor', // Ï∂îÍ∞Ä Í∂åÏû•
            '--no-first-run',
            '--no-default-browser-check',
          ],
        },
      },
      preNavigationHooks: [
        async (crawlingContext) => {
          this.logger.log('üìé Granting clipboard permissions...');
          // crawlingContextÏóêÏÑú page Í∞ùÏ≤¥Î•º Í∞ÄÏ†∏ÏôÄ contextÏóê Ï†ëÍ∑º ÌõÑ Í∂åÌïúÏùÑ Î∂ÄÏó¨Ìï©ÎãàÎã§.
          await crawlingContext.page
            .context()
            .grantPermissions(['clipboard-read', 'clipboard-write']);
        },
      ],

      requestHandler: async ({ page, request, log }) => {
        const { type, videoUrl } = request.userData;
        const { url } = request;
        log.info(`[Processing started] ${url} - Type: ${type}`);

        try {
          const result = await this.handleGeminiScrape(page, url, request.userData);
          const video = await this.youtubeRepository.findVideoByVideoId(videoId);
          if (!video) {
            throw new Error(
              `Database Error: Video with videoId ${videoId} not found after scraping.`,
            );
          }

          if (type === 'json') {
            await this.handleJsonPromptResult(result as JsonPromptResult, video.id);
          } else if (type === 'script') {
            await this.handleScriptPromptResult(result as ScriptPromptResult, video.id);
          }
        } catch (error) {
          this.logger.error(
            {
              message: `[Scraping Failed] An error occurred during request handling for ${url} (Type: ${type})`,
              videoUrl,
              promptType: type,
              error: error.stack,
            },
            error.stack,
          );
          await this.saveDebugInfo(page, `request-handler-failed-${type}`);
          throw error;
        }
      },
      failedRequestHandler: async ({ page, request }, error) => {
        const { type, videoUrl } = request.userData;
        this.logger.error(`Request ${videoUrl} (type: ${type}) failed:`, error);
        await this.saveDebugInfo(page, 'failed-request');
      },
    });

    await crawler.run();
    this.logger.log('‚úÖ Completed all scraping prompts.');
  }

  private async handleJsonPromptResult(json: JsonPromptResult, videoId: string) {
    const { videoInfo } = json;
    await this.youtubeRepository.createVideoJson({
      rawData: json as any,
      youtubeVideo: {
        connect: {
          id: videoId,
        },
      },
    });

    await this.youtubeRepository.updateVideo(
      { id: videoId },
      {
        isRelatedAsset: json.isRelatedAsset,
        summary: videoInfo.summary,
        relatedStocks: json.videoInfo.relatedStocks,
        publishedAt: new Date(videoInfo.publishedAt),
      },
    );
  }

  private async handleScriptPromptResult(json: ScriptPromptResult, videoId: string) {
    await this.youtubeRepository.createVideoScript({
      rawData: json,
      youtubeVideo: {
        connect: {
          id: videoId,
        },
      },
    });
  }

  private async handleGeminiScrape(page: Page, url: string, userData: Dictionary) {
    const { prompt, type } = userData;
    this.logger.log(`ü§ñ [${type}] Starting Gemini prompt processing...`);
    try {
      await page.goto(url, { waitUntil: 'domcontentloaded' });
      await page.waitForTimeout(3000);

      const fined = await this.startNewChat(page, type);
      if (!fined) {
        throw new Error(`[${type}] Failed to start a new chat session.`);
      }
      return await this.inputPromptToGemini(page, prompt, type);
    } catch (error) {
      this.logger.error(`‚ùå [${type}] Error during Gemini scraping:`, error);
      await this.saveDebugInfo(page, `gemini-scrape-failed-${type}`);
      throw error;
    }
  }

  private async startNewChat(page: Page, type: string) {
    this.logger.log(`[${type}] Looking for 'New Chat' button to start a session...`);
    try {
      await page.waitForTimeout(10000);
      await page.click(this.NEW_CHAT_BUTTON_SELECTOR, { timeout: 5000 });
      this.logger.log(`‚úÖ [${type}] 'New Chat' button clicked successfully.`);
    } catch (_error) {
      this.logger.warn(
        `[${type}] 'New Chat' button not found. Assuming already in a chat session.`,
      );
      return false;
    }
    await page.waitForTimeout(2000);
    return true;
  }

  private async inputPromptToGemini(page: Page, prompt: string, type: string) {
    try {
      await this.fillPrompt(page, prompt, type);
      await this.submitPrompt(page, type);
      await this.waitForResponse(page, type);
      return await this.getGeminiResponse(page, type);
    } catch (error) {
      this.logger.error(`‚ùå [${type}] Error in inputPromptToGemini:`, error);
      throw error;
    }
  }

  private async fillPrompt(page: Page, prompt: string, type: string) {
    this.logger.log(`üìù [${type}] Looking for Gemini input area...`);
    await page.waitForSelector(this.INPUT_SELECTOR, { state: 'visible', timeout: 10000 });
    this.logger.log(`‚úÖ [${type}] Gemini ÏûÖÎ†• ÏòÅÏó≠ÏùÑ Ï∞æÏïòÏäµÎãàÎã§.`);
    await page.fill(this.INPUT_SELECTOR, prompt);
    this.logger.log(`‚úçÔ∏è [${type}] ÌîÑÎ°¨ÌîÑÌä∏Î•º Gemini ÏûÖÎ†• ÏòÅÏó≠Ïóê ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏûÖÎ†•ÌñàÏäµÎãàÎã§.`);
  }

  private async submitPrompt(page: Page, type: string) {
    this.logger.log(`üñ±Ô∏è [${type}] Clicking the 'Send' button to submit the prompt...`);
    const SUBMIT_BUTTON_SELECTOR = 'button[aria-label="Î©îÏãúÏßÄ Î≥¥ÎÇ¥Í∏∞"]';

    try {
      await page.waitForSelector(SUBMIT_BUTTON_SELECTOR, {
        state: 'visible',
        timeout: 5000,
      });

      await page.click(SUBMIT_BUTTON_SELECTOR);

      this.logger.log(`‚úÖ [${type}] ÌîÑÎ°¨ÌîÑÌä∏Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†úÏ∂úÎêòÏóàÏäµÎãàÎã§.`);
    } catch (error) {
      this.logger.error(
        `[${type}] Send button could not be found or clicked with selector: ${SUBMIT_BUTTON_SELECTOR}`,
        error,
      );
      await this.saveDebugInfo(page, `submit-failed-${type}`);
      throw new Error(`[${type}] Failed to submit the prompt by clicking the button.`);
    }
  }

  private async waitForResponse(page: Page, type: string) {
    this.logger.log(`‚è≥ [${type}] GeminiÏùò ÏùëÎãµÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ëÏûÖÎãàÎã§...`);
    try {
      this.logger.log(` [${type}] 1Îã®Í≥Ñ: 'ÏΩîÎìú Î≥µÏÇ¨' Î≤ÑÌäºÏù¥ ÎÇòÌÉÄÎÇ† ÎïåÍπåÏßÄ Í∏∞Îã§Î¶ΩÎãàÎã§...`);
      await page.waitForSelector(this.COPY_BUTTON_SELECTOR, {
        state: 'visible',
        timeout: this.TIMEOUT_MILLIS,
      });
      this.logger.log(`‚úÖ [${type}] 'ÏΩîÎìú Î≥µÏÇ¨' Î≤ÑÌäºÏùÑ Ï∞æÏïòÏäµÎãàÎã§.`);
      await page.waitForTimeout(30000); // 30Ï¥à ÎåÄÍ∏∞
      this.logger.log(` [${type}] 2Îã®Í≥Ñ: ÏùëÎãµÏù¥ ÏôÑÎ£åÎê† ÎïåÍπåÏßÄ Ïä§ÌÅ¨Î°§ÌïòÎ©∞ ÎåÄÍ∏∞Ìï©ÎãàÎã§...`);

      await page.waitForFunction(
        ({ conversationSelector, modelResponseSelector, keyword }) => {
          const conversation = document.querySelector(conversationSelector);
          if (!conversation) return false;
          conversation.scrollIntoView({ block: 'end' });

          const modelResponse = document.querySelector(modelResponseSelector);
          return modelResponse?.textContent?.includes(keyword) ?? false;
        },
        {
          conversationSelector: this.LAST_CONVERSATION_SELECTOR,
          modelResponseSelector: this.LAST_MODEL_RESPONSE_SELECTOR, // <-- Ïù¥ ÏÖÄÎ†âÌÑ∞Î•º ÏÇ¨Ïö©
          keyword: this.COMPLETION_KEYWORD,
        },
        { timeout: this.TIMEOUT_MILLIS, polling: 2000 },
      );

      this.logger.log(`‚úÖ [${type}] ÏùëÎãµ ÏôÑÎ£å ÌÇ§ÏõåÎìúÎ•º ÌôïÏù∏ÌñàÏäµÎãàÎã§.`);
      this.logger.log(` [${type}] 3Îã®Í≥Ñ: ÏïàÏ†ïÏÑ±ÏùÑ ÏúÑÌï¥ Ï∂îÍ∞ÄÎ°ú 1Ï¥à ÎåÄÍ∏∞Ìï©ÎãàÎã§...`);
      await page.waitForTimeout(1000);

      this.logger.log(`‚úÖ [${type}] Gemini ÏùëÎãµÏù¥ ÏôÑÏ†ÑÌûà ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.`);
    } catch (error) {
      this.logger.error(`[${type}] Gemini ÏùëÎãµ ÎåÄÍ∏∞ Ï§ë ÏãúÍ∞Ñ Ï¥àÍ≥º ÎòêÎäî Ïò§Î•ò Î∞úÏÉù`, error);
      await this.saveDebugInfo(page, `wait-for-response-failed-${type}`);
      throw new Error(`[${type}] Gemini ÏùëÎãµ ÎåÄÍ∏∞ Ï§ë Ïã§Ìå®ÌñàÏäµÎãàÎã§.`);
    }
  }

  private async getGeminiResponse(page: Page, type: string) {
    this.logger.log(`üñ±Ô∏è [${type}] ÏùëÎãµÏóêÏÑú 'ÏΩîÎìú Î≥µÏÇ¨' Î≤ÑÌäºÏùÑ Ï∞æÍ≥† ÌÅ¥Î¶≠Ìï©ÎãàÎã§...`);

    try {
      await page.waitForSelector(this.COPY_BUTTON_SELECTOR, { state: 'visible', timeout: 10000 });
      await page.click(this.COPY_BUTTON_SELECTOR);
      this.logger.log(`‚úÖ [${type}] 'ÏΩîÎìú Î≥µÏÇ¨' Î≤ÑÌäºÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌÅ¥Î¶≠ÌñàÏäµÎãàÎã§.`);
      await page.waitForTimeout(1000); // 1Ï¥à ÎåÄÍ∏∞
    } catch (error) {
      this.logger.error(
        `[Copy Button Error] 'ÏΩîÎìú Î≥µÏÇ¨' Î≤ÑÌäºÏùÑ Ï∞æÍ±∞ÎÇò ÌÅ¥Î¶≠ÌïòÎäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§. (type: ${type})`,
        error.stack,
      );
      await this.saveDebugInfo(page, `copy-button-failed-${type}`);
      throw new Error(
        `[${type}] 'ÏΩîÎìú Î≥µÏÇ¨' Î≤ÑÌäºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Gemini ÏùëÎãµÏóê ÏΩîÎìú Î∏îÎ°ùÏù¥ Ìè¨Ìï®ÎêòÏóàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.`,
      );
    }

    const clipboardContent = await page.evaluate(() => navigator.clipboard.readText());
    this.logger.log(`üìã [${type}] ÌÅ¥Î¶ΩÎ≥¥Îìú ÎÇ¥Ïö©ÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏùΩÏóàÏäµÎãàÎã§.`);

    if (!clipboardContent) {
      this.logger.error(
        {
          message: `[Clipboard Empty] Clipboard is empty for type: ${type}`,
        },
        'Clipboard Empty',
      );
      throw new Error(`[${type}] ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóêÏÑú ÎÇ¥Ïö©ÏùÑ ÏùΩÏñ¥Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÍ±∞ÎÇò ÎÇ¥Ïö©Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.`);
    }

    // ÏõêÎ≥∏ ÎÇ¥Ïö©ÏùÑ Î®ºÏ†Ä Î°úÍ∑∏Î°ú ÎÇ®ÍπÅÎãàÎã§.
    this.logger.log({
      message: `[Raw Clipboard Content] for type: ${type}`,
      content: clipboardContent,
    });

    try {
      const parsedJson = JSON.parse(clipboardContent);
      this.logger.log(`‚úÖ [${type}] ÌÅ¥Î¶ΩÎ≥¥Îìú ÎÇ¥Ïö©ÏùÑ JSONÏúºÎ°ú ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌååÏã±ÌñàÏäµÎãàÎã§.`);
      this.logger.debug({
        message: `[Debug] Parsed JSON for ${type}`,
        parsedJson,
      });
      return parsedJson;
    } catch (error) {
      this.logger.error(
        {
          message: `[JSON Parse Failed] Failed to parse clipboard content for type: ${type}`,
          clipboardContent: clipboardContent, // ÌååÏã± Ïã§Ìå® Ïãú ÏõêÎ≥∏ ÎÇ¥Ïö©ÏùÑ ÏóêÎü¨ Î°úÍ∑∏Ïóê Ìè¨Ìï®
          error: error.stack,
        },
        error.stack,
      );
      throw new Error(`JSON parsing failed for type ${type}. Check error logs for details.`);
    }
  }

  private async saveDebugInfo(page: Page, stage: string): Promise<void> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    await fs.mkdir(this.DEBUG_PATH, { recursive: true });

    const screenshotPath = path.join(this.DEBUG_PATH, `screenshot-${stage}-${timestamp}.png`);
    try {
      await page.screenshot({ path: screenshotPath, fullPage: true });
      this.logger.log(`üì∏ Screenshot saved to ${screenshotPath}`);
    } catch (error) {
      this.logger.error('Failed to save screenshot:', error);
    }
  }
}
